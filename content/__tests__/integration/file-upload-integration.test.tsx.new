/**
 * Integration Tests: File Upload with API (Jest - Converted from Vitest)
 *
 * Tests the integration between the ExcelImportCard component and the backend API,
 * including file upload, progress tracking, validation, and error handling.
 */

import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import { ExcelImportCard } from '@/components/dashboard/ExcelImportCard';
import { VendorDashboardProvider } from '@/lib/context/VendorDashboardContext';
import * as fileUpload from '@/lib/utils/file-upload';

// Mock the file upload utilities
jest.mock('@/lib/utils/file-upload', () => ({
  uploadFile: jest.fn(),
  validateExcelFile: jest.fn(),
  formatFileSize: jest.fn((bytes: number) => `${(bytes / 1024).toFixed(1)} KB`)
}));

// Mock the hooks
jest.mock('@/hooks/useTierAccess', () => ({
  useTierAccess: jest.fn(() => ({
    hasAccess: true,
    tier: 'tier2',
    upgradePath: null
  }))
}));

// Mock sonner toast
jest.mock('sonner', () => ({
  toast: {
    error: jest.fn(),
    success: jest.fn(),
    warning: jest.fn()
  }
}));

describe('File Upload Integration', () => {
  const mockVendor = {
    id: 'vendor-123',
    name: 'Test Vendor',
    tier: 'tier2' as const
  };

  const createMockFile = (name: string, size: number = 1024 * 1024) => {
    const file = new File(['test content'], name, {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });
    Object.defineProperty(file, 'size', { value: size });
    return file;
  };

  const renderWithContext = (component: React.ReactNode) => {
    return render(
      <VendorDashboardProvider value={{ vendor: mockVendor, loading: false, error: null, refetch: jest.fn() }}>
        {component}
      </VendorDashboardProvider>
    );
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  it('should upload file and receive validation results', async () => {
    const mockResponse = {
      ok: true,
      status: 200,
      json: async () => ({
        phase: 'preview',
        parseResult: {
          success: true,
          rows: [{ name: 'Test' }],
          metadata: { filename: 'test.xlsx', rowCount: 1, columnCount: 1 }
        },
        validationResult: {
          valid: true,
          rows: [{ rowNumber: 1, valid: true, errors: [], warnings: [], data: {} }],
          summary: {
            totalRows: 1,
            validRows: 1,
            errorRows: 0,
            warningRows: 0,
            totalErrors: 0,
            totalWarnings: 0
          },
          errorsByField: {}
        },
        message: 'Validation successful'
      })
    };

    (jest.mocked(fileUpload.uploadFile)).mockResolvedValue(mockResponse as any);
    (jest.mocked(fileUpload.validateExcelFile)).mockReturnValue({ valid: true });

    renderWithContext(<ExcelImportCard />);

    const file = createMockFile('test.xlsx');
    const input = screen.getByRole('textbox', { hidden: true }) as HTMLInputElement;

    // Simulate file selection
    fireEvent.change(input, { target: { files: [file] } });

    await waitFor(() => {
      expect(screen.getByText('Upload and Validate')).toBeInTheDocument();
    });

    // Click upload button
    const uploadButton = screen.getByText('Upload and Validate');
    fireEvent.click(uploadButton);

    await waitFor(() => {
      expect(fileUpload.uploadFile).toHaveBeenCalledWith({
        url: `/api/portal/vendors/${mockVendor.id}/excel-import?phase=preview`,
        file: expect.any(File),
        onProgress: expect.any(Function)
      });
    });

    await waitFor(() => {
      expect(screen.getByText(/Total Rows/)).toBeInTheDocument();
      expect(screen.getByText('1')).toBeInTheDocument();
    });
  });

  it('should handle progress tracking', async () => {
    let onProgressCallback: ((progress: fileUpload.UploadProgress) => void) | undefined;

    const mockResponse = {
      ok: true,
      status: 200,
      json: async () => ({
        phase: 'preview',
        parseResult: { success: true, rows: [] },
        validationResult: {
          valid: true,
          rows: [],
          summary: { totalRows: 0, validRows: 0, errorRows: 0, warningRows: 0, totalErrors: 0, totalWarnings: 0 },
          errorsByField: {}
        },
        message: 'Success'
      })
    };

    (jest.mocked(fileUpload.uploadFile)).mockImplementation((options) => {
      onProgressCallback = options.onProgress;
      return Promise.resolve(mockResponse as any);
    });

    (jest.mocked(fileUpload.validateExcelFile)).mockReturnValue({ valid: true });

    renderWithContext(<ExcelImportCard />);

    const file = createMockFile('test.xlsx');
    const input = screen.getByRole('textbox', { hidden: true }) as HTMLInputElement;

    fireEvent.change(input, { target: { files: [file] } });

    const uploadButton = await screen.findByText('Upload and Validate');
    fireEvent.click(uploadButton);

    // Simulate progress updates
    await waitFor(() => {
      expect(onProgressCallback).toBeDefined();
    });

    if (onProgressCallback) {
      onProgressCallback({ loaded: 512 * 1024, total: 1024 * 1024, percentage: 50 });
    }

    await waitFor(() => {
      expect(screen.getByText(/50%/)).toBeInTheDocument();
    });
  });

  it('should execute import after confirmation', async () => {
    const previewResponse = {
      ok: true,
      status: 200,
      json: async () => ({
        phase: 'preview',
        parseResult: { success: true, rows: [{ name: 'Test' }] },
        validationResult: {
          valid: true,
          rows: [{ rowNumber: 1, valid: true, errors: [], warnings: [], data: {} }],
          summary: { totalRows: 1, validRows: 1, errorRows: 0, warningRows: 0, totalErrors: 0, totalWarnings: 0 },
          errorsByField: {}
        },
        message: 'Success'
      })
    };

    const executeResponse = {
      ok: true,
      status: 200,
      json: async () => ({
        phase: 'execute',
        executionResult: {
          success: true,
          summary: { successCount: 1, errorCount: 0, warningCount: 0 },
          changes: [],
          errors: []
        },
        message: 'Import successful'
      })
    };

    (jest.mocked(fileUpload.uploadFile))
      .mockResolvedValueOnce(previewResponse as any)
      .mockResolvedValueOnce(executeResponse as any);

    (jest.mocked(fileUpload.validateExcelFile)).mockReturnValue({ valid: true });

    renderWithContext(<ExcelImportCard />);

    const file = createMockFile('test.xlsx');
    const input = screen.getByRole('textbox', { hidden: true }) as HTMLInputElement;

    fireEvent.change(input, { target: { files: [file] } });

    const uploadButton = await screen.findByText('Upload and Validate');
    fireEvent.click(uploadButton);

    // Wait for validation to complete
    await waitFor(() => {
      expect(screen.getByText(/All data validated successfully/)).toBeInTheDocument();
    });

    // Click confirm import button
    const confirmButton = screen.getByText('Confirm Import');
    fireEvent.click(confirmButton);

    await waitFor(() => {
      expect(fileUpload.uploadFile).toHaveBeenCalledTimes(2);
      expect(fileUpload.uploadFile).toHaveBeenNthCalledWith(2, {
        url: `/api/portal/vendors/${mockVendor.id}/excel-import?phase=execute`,
        file: expect.any(File),
        additionalData: { confirmed: 'true' }
      });
    });

    await waitFor(() => {
      expect(screen.getByText(/Import Completed Successfully/)).toBeInTheDocument();
    });
  });

  it('should handle network errors gracefully', async () => {
    const networkError = new Error('Failed to fetch');
    (jest.mocked(fileUpload.uploadFile)).mockRejectedValue(networkError);
    (jest.mocked(fileUpload.validateExcelFile)).mockReturnValue({ valid: true });

    renderWithContext(<ExcelImportCard />);

    const file = createMockFile('test.xlsx');
    const input = screen.getByRole('textbox', { hidden: true }) as HTMLInputElement;

    fireEvent.change(input, { target: { files: [file] } });

    const uploadButton = await screen.findByText('Upload and Validate');
    fireEvent.click(uploadButton);

    await waitFor(() => {
      expect(screen.getByText(/Network Error/)).toBeInTheDocument();
    });
  });

  it('should handle 413 payload too large', async () => {
    const mockResponse = {
      ok: false,
      status: 413,
      json: async () => ({ error: 'Payload too large' })
    };

    (jest.mocked(fileUpload.uploadFile)).mockResolvedValue(mockResponse as any);
    (jest.mocked(fileUpload.validateExcelFile)).mockReturnValue({ valid: true });

    renderWithContext(<ExcelImportCard />);

    const file = createMockFile('large-file.xlsx', 6 * 1024 * 1024); // 6MB
    const input = screen.getByRole('textbox', { hidden: true }) as HTMLInputElement;

    fireEvent.change(input, { target: { files: [file] } });

    const uploadButton = await screen.findByText('Upload and Validate');
    fireEvent.click(uploadButton);

    await waitFor(() => {
      expect(screen.getByText(/File size exceeds/)).toBeInTheDocument();
    });
  });

  it('should handle 401 unauthorized', async () => {
    const mockResponse = {
      ok: false,
      status: 401,
      json: async () => ({ error: 'Unauthorized' })
    };

    (jest.mocked(fileUpload.uploadFile)).mockResolvedValue(mockResponse as any);
    (jest.mocked(fileUpload.validateExcelFile)).mockReturnValue({ valid: true });

    renderWithContext(<ExcelImportCard />);

    const file = createMockFile('test.xlsx');
    const input = screen.getByRole('textbox', { hidden: true }) as HTMLInputElement;

    fireEvent.change(input, { target: { files: [file] } });

    const uploadButton = await screen.findByText('Upload and Validate');
    fireEvent.click(uploadButton);

    await waitFor(() => {
      expect(screen.getByText(/Authentication required/)).toBeInTheDocument();
    });
  });

  it('should handle validation errors', async () => {
    const mockResponse = {
      ok: true,
      status: 200,
      json: async () => ({
        phase: 'preview',
        parseResult: { success: true, rows: [{ name: '' }] },
        validationResult: {
          valid: false,
          rows: [
            {
              rowNumber: 1,
              valid: false,
              errors: [{ field: 'name', message: 'Name is required', severity: 'error' as const }],
              warnings: [],
              data: {}
            }
          ],
          summary: { totalRows: 1, validRows: 0, errorRows: 1, warningRows: 0, totalErrors: 1, totalWarnings: 0 },
          errorsByField: { name: 1 }
        },
        message: 'Validation failed'
      })
    };

    (jest.mocked(fileUpload.uploadFile)).mockResolvedValue(mockResponse as any);
    (jest.mocked(fileUpload.validateExcelFile)).mockReturnValue({ valid: true });

    renderWithContext(<ExcelImportCard />);

    const file = createMockFile('test.xlsx');
    const input = screen.getByRole('textbox', { hidden: true }) as HTMLInputElement;

    fireEvent.change(input, { target: { files: [file] } });

    const uploadButton = await screen.findByText('Upload and Validate');
    fireEvent.click(uploadButton);

    await waitFor(() => {
      expect(screen.getByText(/Found 1 rows with errors/)).toBeInTheDocument();
      expect(screen.getByText(/Fix Errors First/)).toBeInTheDocument();
    });
  });

  it('should handle import execution errors', async () => {
    const previewResponse = {
      ok: true,
      status: 200,
      json: async () => ({
        phase: 'preview',
        parseResult: { success: true, rows: [{ name: 'Test' }] },
        validationResult: {
          valid: true,
          rows: [{ rowNumber: 1, valid: true, errors: [], warnings: [], data: {} }],
          summary: { totalRows: 1, validRows: 1, errorRows: 0, warningRows: 0, totalErrors: 0, totalWarnings: 0 },
          errorsByField: {}
        },
        message: 'Success'
      })
    };

    const executeResponse = {
      ok: false,
      status: 500,
      json: async () => ({ error: 'Database error' })
    };

    (jest.mocked(fileUpload.uploadFile))
      .mockResolvedValueOnce(previewResponse as any)
      .mockResolvedValueOnce(executeResponse as any);

    (jest.mocked(fileUpload.validateExcelFile)).mockReturnValue({ valid: true });

    renderWithContext(<ExcelImportCard />);

    const file = createMockFile('test.xlsx');
    const input = screen.getByRole('textbox', { hidden: true }) as HTMLInputElement;

    fireEvent.change(input, { target: { files: [file] } });

    const uploadButton = await screen.findByText('Upload and Validate');
    fireEvent.click(uploadButton);

    await waitFor(() => {
      expect(screen.getByText(/All data validated successfully/)).toBeInTheDocument();
    });

    const confirmButton = screen.getByText('Confirm Import');
    fireEvent.click(confirmButton);

    await waitFor(() => {
      expect(screen.getByText(/Server error/)).toBeInTheDocument();
    });
  });
});
